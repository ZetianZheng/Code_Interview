---
title: 160. Intersection of Two Linked Lists
date: 2023/08/11
author: Runming
type: 题解
---
## Question: 
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

## Solution:

解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。
```java
class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int sizeA = countSize(headA);
        int sizeB = countSize(headB);
        int diff = Math.abs(sizeA - sizeB);

        // 思路：两个链表尾端对齐，长的先走一段，直到两个在同一个起点，之后双指针比较是否相等。第一个相等的输出
        return sizeA < sizeB ? getInterNode(headA, headB, diff) : getInterNode(headB, headA, diff);
    }

    // 计算链表长度
    private int countSize(ListNode a) {
        int size = 0;

        while(a != null) {
            a = a.next;
            size++;
        }

        return size;
    }

    private ListNode getInterNode(ListNode headA, ListNode headB, int diff) {
        // size of ListNode headA < ListNode headB;
        // headB 先移动diff次，向右对齐
        ListNode currB = headB;
        while (diff != 0) {
            currB = currB.next;
            diff--;
        }

        // 开始比较，返回第一个相交点
        ListNode currA = headA;

        while (currA != null) {
            if (currA == currB) {
                return currA;
            }

            currA = currA.next;
            currB = currB.next;
        }

        return null;
    }
}
```

### 环形链表技巧：  

设相交长度为c，headA headB 为a,b

那么：
```
a + b - c = b + a - c
```
如果两个链表相交，那么交点之后的所有节点都是共同的。这个方法的巧妙之处在于使得两个指针在走完两个链表后，在走到相交处之前，都走过了相同长度的路径。
```java
class Solution {
        ListNode a = headA;
        ListNode b = headB;
        
        while (a != b) {
            a = a == null ? headB : a.next;
            b = b == null ? headA : b.next;
        }
        // headA: 41723
        // headB: 52623
        
        // a : 4172352623
        // b : 5262341723
        return a; // 即使没有交叉点，也会在第二次循环停下(a 和b都是null），此时a是null
    }
}
```