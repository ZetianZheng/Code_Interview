---
title: 93. Restore IP Addresses
date: 2023/05/15
author: Runming
type: 题解
---

> 跟[[131. Palindrome Partitioning]]很像，需要更多的考虑剪枝情况，以及在哪里剪枝  
> - 最大不同： 不能无限切割，第三个切割点到字符串的末尾就是最后一个子串，所以需要在终止条件中进行判断和回溯维护路径。

## Resource
- [回溯算法如何分割字符串并判断是合法IP？| LeetCode：93.复原IP地址_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XP4y1U73i/?vd_source=11fa18bc276af3bba75dd7f376bfe9c9)


# [Restore IP Addresses - LeetCode](https://leetcode.com/problems/restore-ip-addresses/description/)
## Tag
#combination, #Partition


## 审题（关键词） 
给一个字符串，找所有有效ip的组合


## 初始思路  
跟切割字符串很像，  

决策树是找切割点，一共三个切割点，叶子节点是答案  
使用剪枝来完成valid的条件： 没有head 0， 数字0到255， 全为数字  

参数：ans， path， 切割点数量, startIndex  
终止值：切割点数量为0，切割点起始为3， 因为一共四段
				
## 考点  
组合，回溯，切割类问题


## 解法  
```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12) return new ArrayList<String>(); // 算是剪枝了

        // 给一个字符串，找所有有效ip的组合
        // 跟切割字符串很像，
        // 决策树是找切割点，一共三个切割点，叶子节点是答案
        // 使用剪枝来完成valid的条件： 没有head 0， 数字0到255， 全为数字
        // 参数：ans， path， 切割点数量, startIndex
        List<String> path = new ArrayList<>();
        List<List<String>> ans = new ArrayList<>();

        backTracking(s, ans, path, 0, 3);
        return convertAns(ans);
    }

    void backTracking(String s, List<List<String>> ans, List<String> path, int startIndex, int dotNum) {
        // 终止条件：可切割点为0
        if (dotNum == 0) {
            if (isValid(s, startIndex, s.length() - 1)) {
                path.add(s.substring(startIndex, s.length()));
                ans.add(new ArrayList<>(path));
                path.remove(path.size() - 1); // 此处依然需要回溯， 返回时维护正确的路径
            }
            return ;
        }

        // for loop: 遍历选择列表，选择切割点
        for (int i = startIndex; i < s.length(); i++) {
            // 剪枝： 判断isValid之后再做递归和回溯。
            // 左闭右闭
            if (isValid(s, startIndex, i)) {
                String curr = s.substring(startIndex, i + 1);
                // 处理：增加路径，更新dotNum, stratIndex
                path.add(curr);
                // 访问
                backTracking(s, ans, path, i + 1, dotNum - 1);
                // 处理：回溯路径，更新dotNum, stratIndex
                path.remove(path.size() - 1);
            } else {
                break; // 有一个不合法，后面都可以剪枝
            }
        }
    }

    List<String> convertAns(List<List<String>> ans) {
        List<String> validIps = new ArrayList<>();
        for (List<String> ip : ans) {
            StringBuilder sb = new StringBuilder();
            int i = 3;
            for (String s : ip) {
                sb.append(s);
                if (i > 0) {
                    sb.append(".");
                }
                i--;
            }
            validIps.add(sb.toString());
        }

        return validIps;
    }
 
    // 判断 s的start 到index是否合法
    // 左闭右闭
    boolean isValid(String s, int start, int end) {
        if (start > end) {
            return false;
        }

        int len = end - start + 1;

        // 0开头的数字不合法
        if (len > 1 && s.charAt(start) - '0' == 0) {
            return false;
        }

        // 长度大于3不合法
        if (len > 3) {
            return false;
        }

        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到⾮数字字符不合法
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');
            if (num > 255) { // 如果⼤于255了不合法
                return false;
            }
        }

        return true;
    }
}
```

## 难点
- 思路：想到切割类组合问题
- 代码： 
如何判断valid  
在哪里进行剪枝  