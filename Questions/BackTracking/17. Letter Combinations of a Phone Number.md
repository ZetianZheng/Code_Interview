---
title: 17. Letter Combinations of a Phone Number
date: 2023/05/12
author: Runming
type: 题解
---

# [Letter Combinations of a Phone Number - LeetCode](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)

## Tag
#combination, #backtracking


## 审题（关键词） 
Combination, phone number


## 初始思路  
依然是组合问题，如果暴力的话需要n个for循环， 所以想到使用递归加回溯。  
决策树：  
树枝： 选择当前数字的字符选项列表  
节点：记录当前路径（一个可能的组合）  
digits的长度就是决策树的深度。

## 考点  
回溯，选择列表
## 解法  
```java
class Solution {
    private String[] numString;
    public List<String> letterCombinations(String digits) {
        List<String> ans = new ArrayList<>();
        StringBuilder pathSb = new StringBuilder();

        if (digits == null || digits.length() == 0) {
            return ans;
        }
        // create num -> string mapping:
        numString = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

        
        // 参数：
        // digits: 所有选择列表，控制树的深度
        // pathSb: 目前的路径，一个组合
        // ans: 所有路径
        // index: 控制现在是哪一层，digits的第几个数字
        backTracking(digits, pathSb, ans, 0);

        return ans;
    }

    public void backTracking(String digits, StringBuilder path, List<String> ans, int index) {
        // bc:
        if (index == digits.length()) {
            ans.add(path.toString());
            return ;
        }

        // get 当前选择列表：
        String choiceList = numString[digits.charAt(index) - '0'];

        // for loop, 递归所有的当前的选择列表：
        for (int i = 0; i < choiceList.length(); i++) {
            // pre handle: 
            path.append(choiceList.charAt(i));

            // 去下一个数字列表选择
            backTracking(digits, path, ans, index + 1);

            // post handle: remove last choice
            path.deleteCharAt(path.length() - 1);
        }

    }
}
```

## 难点
每一个数字的遍历index实际上是由for循环控制，  
在决策树上看，一个递归结束后，会回到这个节点，进行下一个树枝的选择，有多少个树枝这个for循环的size就是多大。