# [Lowest Common Ancestor of a Binary Tree - LeetCode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)
## Tag
binary tree,postOrder
## 审题（关键词） 
最近公共祖先
## 初始思路 
这题需要先找到两个节点，然后从下往上访问找到公共父节点。  
需要注意的是，访问是没有办法从下往上的，  
但是我们可以利用后序遍历，处理在最后处理。

## 考点  
后序遍历
技巧：使用数字记录是否找到节点，如果找到就返回1，如果同时找到就返回2.
## 解法  
```java
class Solution {
    TreeNode ancestor;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 后序遍历
        // 参数：不需要，返回值：可以返回找到的节点数量
        // 遍历：左右子树找到的节点数量
        // 处理：本节点是否找到两个节点：
        ancestor = null;
        traverse(root, p, q);
        return ancestor;
    }

    private int traverse(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return 0;
        }

        // 访问： 找到左右子树的p和q的数量
        int left = traverse(root.left, p, q);
        int right = traverse(root.right, p, q);
        
        // 处理：如果找到第一个值为2，更新ancestor
        int curr = left + right;
        if (root.val == p.val || root.val == q.val) {
            curr += 1;
        }

        if (curr == 2 && ancestor == null) {
            ancestor = root;
        }

        return curr;
    }
}
```

## 难点
