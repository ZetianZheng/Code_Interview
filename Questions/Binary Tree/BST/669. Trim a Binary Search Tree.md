## Tag
#BST, #preorder

## 审题（关键词）
修剪BST

## 初始思路  
- 遍历找到左边界，删除左边界节点以及它的所有左子树，保留右子树顶替它的位置  
- 遍历找到右边界，删除右边界节点以及它的所有右子树，保留左子树顶替它的位置  

## 考点  
BST基本操作, BST 前序常用框架
## 解法  
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        // 前序遍历框架， 利用BST特性左子树比本节点小，右子树比本节点大。
        // 参数和定义：参数一致，返回BST删减后的本节点
        // 处理： 1. root.val < low, 返回本子树的右边符合条件的节点。
        // 处理： 2. root.val > low, 返回本子树的左边符合条件的节点。
        // 递归修剪左右子树
        if (root == null) {
            return null;
        }

        // 处理： 
        // trim 掉左边包括自己的所有节点，所以返回右子树符合条件的节点
        if (root.val < low) {
            return trimBST(root.right, low, high);
        }
        // trim 掉右边包括自己的所有节点，所以返回左子树符合条件的节点
        if (root.val > high) {
            return trimBST(root.left, low, high);
        }
        
        // 访问：如果本节点符合要求，修剪左右子树。
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```

## 难点
如何实现代码。需要弄清每一层的物理意义：每一层返回修剪后的树即可。
