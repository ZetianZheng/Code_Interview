## Tag
#BST, #Construct, #HeighBalanced
## 审题（关键词） 
构建树，数组转换， heigh balanced

## 初始思路  
heigh balanced 意味着需要找到中点，左右两边树的高度差不超过1.
使用三个参数：nums, start, end,
找到mid点，左右两个树递归构建。
比654 好做一点，因为BST的中点就是当前根节点
## 考点  
BST,
## 解法 
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        // 递归构造，定义：返回构造好的树节点
        return construct(nums, 0, nums.length);
    }
    /**
        * 递归构造，定义：返回构造好的树节点
        * 参数：构造数组，区间
        * 循环不变量： 左闭右开
     */
    TreeNode construct(int[] nums, int left, int right) {
        // 左闭右开
        if (left >= right) {
            return null;
        }

        // 处理：
        int mid = (left + right) / 2;
        TreeNode root = new TreeNode(nums[mid]);

        // 访问：
        root.left = construct(nums, left, mid);
        root.right = construct(nums, mid + 1, right);
        return root;
    }
}
```

## 难点
本题跟二分搜索框架很像，  
关于循环不变量：看binarySearch
