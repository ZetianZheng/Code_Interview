## Resouce:
[代码随想录](https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E9%80%92%E5%BD%92%E6%B3%95)
# [Lowest Common Ancestor of a Binary Search Tree - LeetCode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)
## Tag
#BST， #ancestor

## 审题（关键词）
BST，最近公共祖先

## 初始思路  
于[[236. Lowest Common Ancestor of a Binary Tree]]]一样，都是求公共子树，      
如何利用BST的条件？    
- 可以快速找到p和q?
- 对最近公共父节点在BST中的理解：
	- BST中最近公共父节点一定在p和q的中间，
	- 也就意味着，p和q一个在它左子树，一个在它右子树或等于它本身
	- 所以可以从上往下遍历，第一个满足这个条件的就是ancestor


## 考点  
BST，最近公共子节点

## 解法  
> 遍历框架：BST中p，q最近公共节点的物理意义：从上往下遍历的第一个骑着pq之间的节点。
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 遍历框架：前序遍历
        // 处理：当前值val和p，q的值比较
        // 1. 当pq均大于val, 则去右子树找
        // 2. 当pq均小于val, 则去左子树找
        // 3. 当val在pq中间或相等, 则是父节点
        if (root == null) {
            return null;
        }

        // 保证p节点比q小, 方便代码
        if (p.val > q.val) {
            return lowestCommonAncestor(root, q, p);
        }

        // 处理： BST中p，q最近公共节点的物理意义：从上往下遍历第一个骑着pq之间的节点。
        if(root.val >= p.val && root.val <= q.val) {
            return root;
        }

        // 访问： 同样利用了BST的快速搜索的特性
        if (root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right, p, q);
        }

        if (root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        return null;
    }
}
```

> 更简单的写法：
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```

> 迭代版本：
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while (true) {
            if (root.val > p.val && root.val > q.val) {
                root = root.left;
            } else if (root.val < p.val && root.val < q.val) {
                root = root.right;
            } else {
                break;
            }
        }
        return root;
    }
}
```
## 难点
如何联系最近公共和BST的特性。  
刚开始还是惯性思维用236，想利用BST找到p和q再回溯找父节点， 可以用遍历思维看看遍历可否解决问题？  