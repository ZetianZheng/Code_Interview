---
title: 583. Delete Operation for Two Strings
date: 2023/06/12
author: Runming
type: 题解
---


# [Delete Operation for Two Strings - LeetCode](https://leetcode.com/problems/delete-operation-for-two-strings/description/)
## Tag
#double_array, #dp, #LCS

## 审题（关键词） 
给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

## 初始思路  
> 与 [[72. Edit Distance]] 少了插入和替换操作，只剩下删除操作：  

解法1： 求LCS，总长度减去LCS的长度
### 解法2：
1. dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
2. 当word1[i - 1] 与 word2[j - 1]相同的时候
   1. 不需要删除元素：dp[i][j] = dp[i - 1][j - 1]
3. 当word1[i - 1] 与 word2[j - 1]不相同的时候
   1. 需要删除左边或者右边的1个元素，
      1. 删 word1[i - 1] : dp[i][j] = dp[i - 1][j] + 1 
      2. 删 word2[j - 1] : dp[i][j] = dp[i][j - 1] + 1 
   2. 删除两边的所有元素
      1. dp[i][j] = dp[i - 1][j - 1] + 2;
   3. 取最小
4. 初始化：dp[i][0] 表示word1[i - 1] 删到空，需要i步操作。dp[0][j] 表示word2[j - 1] 删到空，需要j步操作。
## 考点  

## 解法  
```java
class Solution {
    public int minDistance(String word1, String word2) {
        
        int lcs = longestCommonSubsequence(word1, word2);
        return word1.length() + word2.length() - 2 * lcs;
    }

    private int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();

        // dp[i][j] will hold the length of the LCS between s1[0..i-1] and s2[0..j-1]
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // If the current character of both strings is the same, it means we found a common character
                    // So, we increment the length of LCS found till now
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // If the current character of the strings are not the same, 
                    // we take the maximum length of LCS found till the previous character of either string
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }
}
```
> 解法2： dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
```java
// dp数组中存储需要删除的字符个数
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i < word1.length() + 1; i++) dp[i][0] = i;
        for (int j = 0; j < word2.length() + 1; j++) dp[0][j] = j;
        
        for (int i = 1; i < word1.length() + 1; i++) {
            for (int j = 1; j < word2.length() + 1; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }else{
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2,
                                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        
        return dp[word1.length()][word2.length()];
    }
}
```
## 难点
dp的定义，想到LCS
