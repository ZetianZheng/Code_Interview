---
title: 96. Unique Binary Search Trees
date: 2023/06/01
author: Runming
type: 题解
---

# [Unique Binary Search Trees - LeetCode](https://leetcode.com/problems/unique-binary-search-trees/description/)
## resource:
1. [手把手带你刷二叉搜索树（第三期）](https://appktavsiei5995.pc.xiaoe-tech.com/p/t_pc/course_pc_detail/image_text/i_62987940e4b01a4852072f8c)
2. [代码随想录](https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF)
## Tag
#dp, #BST

## 审题（关键词） 
节点数为n的bst可以由几种排列方式

## 初始思路  
1. 利用数学归纳法看n = 1， 2， 3 各有什么pattern：发现：   
    - ```dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]```
2. 利用bst的特性：根节点是n个情况，左右子树因为BST的特性，必然是左边当前小于n的x - 1个节点和右边当前大于n的(n - x) 个节点的乘积。所以可以使用从上而下的递归方法。
## 考点  

## 解法  
```java
class Solution {
    public int numTrees(int n) {
        // 1. dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;

        
        // 2. dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
        // 3. 确定遍历顺序 左到右，
        for (int i = 2; i <= n; i++) {
            // 内循环确定左右子树的个数
            for (int j = 1; j <= i; j++) {
                // 注意j需要减1，表明是root节点（开始0是root节点，所以左边没有节点）
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }

        
        return dp[n];

    }
}
```

> 自顶向下：
```java
/* 主函数 */
int numTrees(int n) {
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    // base case
    if (lo > hi) return 1;

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    return res;
}
```
## 难点
归纳思想，从n=1， n = 2 ... 考虑  
一开始被BST迷惑了，想到BST的构造一题