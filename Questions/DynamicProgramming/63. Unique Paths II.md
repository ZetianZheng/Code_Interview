## Tag
#dp

## 审题（关键词） 
跳方格，只能从左到右或者从上到下, 有障碍物

## 初始思路  
比[[62. Unique Paths]]不同的在于有障碍物，不能通过障碍物往后前进。
1. 状态：每个方格的路径总数：
2. 选择：只能向右或者向下 -> 这个方格可以从哪些方格过来(左或者上）当前障碍物则跳过，路径为0.
3. dp数组的初始化： 最上一层和最左一层是1，只有一条路， 有障碍物则跳过之后的所有方格（不可抵达）
4. 确定遍历顺序： 从左到右从上到下
## 考点  
dp

## 解法  
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int row = obstacleGrid.length;
        int col = obstacleGrid[0].length;
        int[][] dp = new int[row][col];
        // 最上一层
        for (int i = 0; i < row; i++) {
            // 有障碍物则跳过之后的所有方格（不可抵达）
            if (obstacleGrid[i][0] == 1) {
                break;
            }
            dp[i][0] = 1;
        }

        // 最左一层
        for (int i = 0; i < col; i++) {
            // 有障碍物则跳过之后的所有方格（不可抵达）
            if (obstacleGrid[0][i] == 1) {
                break;
            }
            dp[0][i] = 1;
        }

        // 从上到下
        for (int i = 1; i < row; i++) {
            // 从左到右
            for (int j = 1; j < col; j++) {
                // 遇到障碍物则跳过
                if (obstacleGrid[i][j] == 1) {
                    continue;
                }
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                // System.out.println(i + " - " + j + ":" + dp[i - 1][j] + " : " + dp[i][j - 1]);
            }
        }

        return dp[row - 1][col - 1];
    }
}
```
## 难点

