---
title: 300. Longest Increasing Subsequence
date: 2023/06/11
author: Runming
type: 题解
---

# [Longest Increasing Subsequence - LeetCode](https://leetcode.com/problems/longest-increasing-subsequence/)
## 审题（关键词）
#LIS, #dp

## 初始思路  
求最值，首先想到穷举法Proof by exhaustion，本题找最长的子序列，   
穷举求最值一般使用动态规划，所以我们套用动态规划的思路看是否解决：


定义：dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度
1. 找状态和选择：
	- 状态：一个array的状态基本上是index， 到这个index的最长长度子序列。
	- 选择：最终结果是找到最长 且求长度，那么选择就是
    	- 当前值比路径上末尾的值大，路径 + 1，
    	- 或者重新开始一个序列，
	- 状态转移or定义：到index的最长子序列大小。它可以被选择影响。
	- 符合最优子结构吗？符合的，最终结果是最长，如果到每一个index的值都是最大，那么最终index就是最大。
2. 最终结果： dp数组的最大值。

3. 难点：这个子序列是不连续的，如何找到最长的子序列？
数学归纳法：假设我们已经知道了 dp[0..4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢？
穷举，每个值都和前面所有的值比较，求最长路径，时间复杂度：(n^2)

## 考点  
经典一维dp。

## 解法  
```java
/**
 * Solution类，包含一个方法用于查找给定数组的最长上升子序列的长度
 */
class Solution {
    /**
     * 方法用于查找给定数组的最长上升子序列的长度
     *
     * @param nums 给定的整型数组
     * @return 给定数组的最长上升子序列的长度
     */
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = 1;
        // 循环所有的index
        for (int i = 1; i < nums.length; i++) {
            // 找到最大的长度
            for (int j = 0; j < i; j++) {
                // 如果之前有一个值比当前值小，则之前长度加1.
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
            }

            // 选择：之前最长的值加1，或者重置为1
            dp[i] = Math.max(dp[i], 1);
        }

        // 结果：所有数组中的最大值
        return Arrays.stream(dp).max().getAsInt();
    }
}

```