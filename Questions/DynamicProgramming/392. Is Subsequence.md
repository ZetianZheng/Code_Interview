---
title: 392. Is Subsequence
date: 2023/06/12
author: Runming
type: 题解
---

# [Is Subsequence - LeetCode](https://leetcode.com/problems/is-subsequence/description/)
## Tag
#binary_search, #double_array, #dp

## 审题（关键词） 
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

## 初始思路  
```
dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。

递推
	元素相同
		公共子序列的长度加1
			dp[i][j] = dp[i - 1][j - 1] + 1
	元素不同
		删减当前一个（t index j-1) , 
        当前相同的子序列的长度为：dp[i][j - 1](t index j - 2)
			dp[i][j] = dp[i][j - 1]
```

## 考点  

## 解法  
```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        // 两个数组比较，
        int sLen = s.length();
        int tLen = t.length();
        // dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。
        // 预留出0是为了判断空的情况，方便初始化
        int[][] dp = new int[sLen + 1][tLen + 1];

        // 遍历S: 0 ~ len - 1
        for (int i = 1; i <= sLen; i++) {
            // // 遍历T: 0 ~ len - 1
            for (int j = 1; j <= tLen; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    // 相等： 公共子序列长度加1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 不相等，看 s : i-1 和 t : j-2 比较的结果
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
   
        // for (int[] row: dp) {
        //     System.out.println(Arrays.toString(row));
        // }

      

        return dp[sLen][tLen] == sLen;
    }
}
```

## 难点
二分法见： [二分查找高效判定子序列 :: labuladong的算法小抄](https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/er-fen-cha-9588f/)