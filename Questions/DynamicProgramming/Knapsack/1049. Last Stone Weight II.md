---
title: 1049. Last Stone Weight II
date: 2023/06/05
author: Runming
type: 题解
---

## Tag
#0-1knapsack, #dp

## 审题（关键词） 
smash stones together
at most one stone left, return the smallest left stone  

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

## 初始思路  
1. 和[[416. Partition Equal Subset Sum]] 很像，需要找到两个集合，将所有的石头放入这两个集合， 使他们的sum尽可能相近，  
2. 所以选取一个背包：sum/2,看这个背包最多能装多少块石头 
   1. 这一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。
   2. 相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。

递归思路：
1. dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]。
2. 本题中于经典01背包不同的地方在于dp[j] 的定义即是价值，也是物品的重量。
    ```
    01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    本题则是：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
    ```
3. dp数组如何初始化: 
## 考点  

## 解法  
```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        int len = stones.length;
        for (int i = 0; i < len; i++) {
            sum += stones[i];
        }

        // 0 1 knapsack:
        // 1. 定义：dp[i] 重量为i的背包，可以背的物品最大重量总和为dp[i]
        // 2. 初始化: 重量为0的背包 物品最大总和均为0.求两堆石头重量相近，则取对半为target
        int target = sum / 2;
        int[] dp = new int[target + 1];

        // 3. 遍历顺序：
        // 外层循环：循环物品（数字）
        for (int i = 0; i < len; i++) {
            // 内层循环：循环背包重量：
            // j >= nums[i] 当背包剩余大小大于当前物品时才可以装入。
            // 倒序循环：详见01 背包解析
            for (int j = target; j >= stones[i]; j--) {
                // 4. 递推公式：
                // 不取当前物品，
                // 取当前物品
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }

        int another = sum - dp[target];

        return another - dp[target];
    }
}
```

## 难点
问题转换为01背包问题：
1. 选择：01背包只有两个状态取或者不取
2. 目标：尽可能填满背包
3. 每个物品只可以取一次。