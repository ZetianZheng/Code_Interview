---
title: 474. Ones and Zeroes
date: 2023/06/05
author: Runming
type: 题解
---

# [Ones and Zeroes - LeetCode](https://leetcode.com/problems/ones-and-zeroes/description/)
## Tag
#0-1knapsack, #dp

## 审题（关键词） 
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。


## 初始思路  
- 求m个0, n个1的最大子集
- 这个子集（背包）选择每个物品进入，要求m个0, n个1（特征）
- 每个物品进入或者不进入(选择），物品的特征是0和1的数量.
1. 状态：这就是一个典型的01背包！ 只不过物品的重量有了两个维度而已。
   1. 本题中strs 数组里的元素就是物品，每个物品都是一个！
   2. 而m 和 n相当于是一个背包，两个维度的背包。
2. dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]
   1. 要是把当前的物品加入，则两维重量分别减去x和y, 子集数量+1
   2. 如果不加入，就是保留上一层的0和1的数量状态。
3. 所以dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1);


## 考点  
[[0-1knapsack]]


## 解法  
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]
        int[][] dp = new int[m + 1][n + 1];

        for (String str : strs) {
            int[] zeroOne = getZeroOne(str);
            int zero = zeroOne[0];
            int one = zeroOne[1];

            for (int i = m; i >= zero; i--) {
                for (int j = n; j >= one; j--) {
                    // 不取，取
                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1);
                }
            }
        }

        return dp[m][n];
    }

    int[] getZeroOne(String str) {
        int[] zeroOne = new int[2];
        for (char ch : str.toCharArray()) {
                if (ch == '0') {
                    zeroOne[0]++;
                } else {
                    zeroOne[1]++;
                }
        }

        return zeroOne;
    }
}
```

## 难点
多个维度的背包和物品如何处理，本质还是01背包的框架