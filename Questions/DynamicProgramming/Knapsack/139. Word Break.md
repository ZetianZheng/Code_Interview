---
title: 139. Word Break
date: 2023/06/08
author: Runming
type: 题解
---

# [Word Break - LeetCode](https://leetcode.com/problems/word-break/description/)
## Tag
#knapsack, #permutations, #dp

## 审题（关键词） 
给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。


## 初始思路  
- 单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。
	单词无限使用，完全背包
- dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。
-  if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。
-  遍历方向：排列，先背包再物品。

## 考点  
完全背包，回溯。

## 解法  
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 单词是物品，s就是背包，单词能组合成s，则可以装满背包。
        // dp[i] 字符串长度为i，是否可以字典组成。
        boolean[] dp = new boolean[s.length() + 1];
        HashSet<String> set = new HashSet<>(wordDict);
        // 初始化：0一定可以被组成
        dp[0] = true;

        //  if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。
        // 求排列：apple pen的顺序不能是pen apple
        for (int j = 1; j <= s.length(); j++) {
            // 物品：
            // 跳过dp[j] 已经是true的
            for (int i = 0; i < j && !dp[j]; i++) {
                // 之前的是true，可以组成，[i, j) 在set中，则本字符串也可以被组成。
                if (set.contains(s.substring(i, j)) && dp[i]) {
                    dp[j] = true;
                }
            }
        }

        return dp[s.length()];
    }
}
```

## 扩展：
> 回溯算法+备忘录
```java
class Solution {
    // 记录结果
    List<String> res = new LinkedList<>();
    // 记录回溯算法的路径
    LinkedList<String> track = new LinkedList<>();
    List<String> wordDict;

    // 主函数
    public List<String> wordBreak(String s, List<String> wordDict) {
        this.wordDict = wordDict;
        // 执行回溯算法穷举所有可能的组合
        backtrack(s, 0);
        return res;
    }

    // 回溯算法框架
    void backtrack(String s, int i) {
        // base case
        if (i == s.length()) {
            // 找到一个合法组合拼出整个 s，转化成字符串
            res.add(String.join(" ", track));
            return;
        }

        // 回溯算法框架
        for (String word : wordDict) {
            // 看看哪个单词能够匹配 s[i..] 的前缀
            int len = word.length();
            if (i + len <= s.length()
                && s.substring(i, i + len).equals(word)) {
                // 找到一个单词匹配 s[i..i+len)
                // 做选择
                track.addLast(word);
                // 进入回溯树的下一层，继续匹配 s[i+len..]
                backtrack(s, i + len);
                // 撤销选择
                track.removeLast();
            }
        }
    }
}
```