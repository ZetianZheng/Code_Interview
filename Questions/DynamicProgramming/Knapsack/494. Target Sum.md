---
title: 494. Target Sum
date: 2023/06/05
author: Runming
type: 题解
---

# [Target Sum - LeetCode](https://leetcode.com/problems/target-sum/description/)
## Tag
#0-1knapsack, #dp

## 审题（关键词） 
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

## 初始思路  
只有加减两个符号：那么每个数字可以做的选择也就两个： 放入+ 堆或者放入-堆
那么可以简化问题为：01背包：
对于每一个数字，选择放入或者不让入 + 堆


目标：给背包容量，问有多少种方法可以装满背包

1. dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法
2. 递推公式：和 [[70. Climbing Stairs]] 很像，当前楼梯是前一步或者前两步爬过来的，所以当前的组合是之前两个之和。
    ```
    这个公式在后面在讲解背包解决排列组合问题的时候还会用到！
    dp[j] += dp[j - numbers[i]];
    ```
3. 从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。

## 考点  
[[0-1knapsack]]


## 解法  
```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            sum += nums[i];
        }

        // a - b = target
        // a + b = sum;
        // a = target + b;
        // 2a = target + b + a
        if ((target + sum) % 2 != 0) {
            // 没有方案， 无法得到target
            return 0;
        }

        if (Math.abs(target) > sum) {
            // 没有方案， 无法得到target,全为负值也不可。
            return 0;
        }
        int t = (target + sum) / 2;
        t = Math.abs(t);
        int[] dp = new int[t + 1];
        // 初始化：正数为0的所有组合为1.
        dp[0] = 1;
        // 经典01背包遍历顺序
        for (int i = 0; i < len; i++) {
            for (int j = t; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }

        return dp[t];
    }
}
```

## 难点
1. 想清楚递推公式是所有之前的组合的累加。
2. dp[0]要初始化为1