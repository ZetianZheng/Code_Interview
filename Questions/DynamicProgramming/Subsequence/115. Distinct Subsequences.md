---
title: 115. Distinct Subsequences
date: 2023/06/12
author: Runming
type: 题解
---

# [Distinct Subsequences - LeetCode](https://leetcode.com/problems/distinct-subsequences/)
## Tag
#double_array, #dp
## 审题（关键词） 
给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 

## 初始思路  
1. dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
2. 递推
   1. s[i - 1] 与 t[j - 1]相等， 两种情况：
      1. 用s[i-1]匹配：dp[i][j] = dp[i - 1][j - 1]
      2. 不用s[i-1]匹配（用s[i - 2], t[j - 1])：dp[i][j] = dp[i - 1][j]
      3. 例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。
      4. 方法个数：dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
   2. s[i - 1] 与 t[j - 1] 不相等
      1. 不用s[i-1]匹配 dp[i][j] = dp[i - 1][j];
3. 初始化：
   1. ![ds](attachment/2023-06-12-00-22-09.png)
   2. dp[i][0] i - 1结尾的s，删除元素得到空字符串的方法个数：1
   3. dp[0][j] 空字符串，删除元素得到t的方法个数：0，不可能
   4. dp[0][0] 空字符串删除元素得到空的方法个数：1
4. ![ds2](attachment/2023-06-12-00-25-16.png)

## 考点  
两个字符串比较求个数, 可以用dp思路试试。


## 解法  
```java
class Solution {
    public int numDistinct(String s, String t) {
        // 两个数组比较，
        int sLen = s.length();
        int tLen = t.length();
        // dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
        // 预留出0是为了判断空的情况，方便初始化
        int[][] dp = new int[sLen + 1][tLen + 1];

        // 初始化：
        for (int i = 0; i <= sLen; i++) {
            dp[i][0] = 1;
        }


        // 遍历S: 0 ~ len - 1
        for (int i = 1; i <= sLen; i++) {
            // // 遍历T: 0 ~ len - 1
            for (int j = 1; j <= tLen; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    // 相等： 分两种情况，
                    // 用S[i-1]匹配， 不用S[i-1]匹配: 即s[i - 2] 和 t[j - 1]匹配的个数之和
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    // 不相等， 不用S[i-1]匹配 
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
   
        // for (int[] row: dp) {
        //     System.out.println(Arrays.toString(row));
        // }

      

        return dp[sLen][tLen];
    }
}
```

## 难点
s[i - 1] 与 t[j - 1]相等， 两种情况：
   1. 用s[i-1]匹配：dp[i][j] = dp[i - 1][j - 1]
   2. 不用s[i-1]匹配（用s[i - 2], t[j - 1])：dp[i][j] = dp[i - 1][j]
   3. 例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s