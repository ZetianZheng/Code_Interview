---
title: 135. Candy
date: 2023/05/23
author: Runming
type: 题解
---
# [Candy - LeetCode](https://leetcode.com/problems/candy/description/)
## Resource
[代码随想录](https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html#%E6%80%9D%E8%B7%AF)
## Tag

## 审题（关键词） 
根据评分分发糖果，要求评分高的比他两边给的糖果多
## 初始思路  
：
1. 每个小孩给的糖果尽可能少。
1. 每个小孩给的刚好比他旁边的人多或者都少？
	1. 这个小孩rating最高，取他两边的最高值，加1
	2. 这个小孩rating比两边低，则两边的最低值，减1
	3. 这个小孩比一边高一边低，则取最低值 加1.

贪心算法：
1. 两边都看，先看一边再看另一边
   1. 左往右：右边更大才加1，不然置为1
   2. 右往左：左边更大加1，不然置为1
   3. 取两者最大值，这样能满足ratings
	

## 考点  

## 解法  
那么本题我采用了两次贪心的策略：

- 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
- 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。
- 这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。

#
```java
class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        int[] lessCandies = new int[len];
        lessCandies[0] = 1;

        // 左往右：
        for (int i = 1; i < len; i++) {
            // 右比左大
            if (ratings[i] - ratings[i - 1] > 0) {
                lessCandies[i] = lessCandies[i - 1] + 1;
            } else {
                lessCandies[i] = 1;
            }
        }

        int sum = lessCandies[len - 1];
        // 右往左：
        for (int i = len -  2; i >= 0; i--) {
            // 左比右大
            if (ratings[i] - ratings[i + 1] > 0) {
                // 保留当前最大或者从左到右最大，满足rating两边比较的条件
                lessCandies[i] = Math.max(lessCandies[i], lessCandies[i + 1] + 1);
            } else {
                // 保留当前最小或者从左到右最大，满足rating两边比较的条件
                lessCandies[i] = Math.max(lessCandies[i], 1);
            }
            sum += lessCandies[i];
        }

        return sum;
    }
}
```

## 难点
处理好一边再处理另一边。两边分别局部，最值是最优