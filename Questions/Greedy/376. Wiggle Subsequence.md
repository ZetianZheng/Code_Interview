---
title: 376. Wiggle Subsequence
date: 2023/05/20
author: Runming
type: 题解
---

# [Wiggle Subsequence - LeetCode](https://leetcode.com/problems/wiggle-subsequence/description/)
## Resource:
[代码随想录](https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF1-%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95)


## Tag
#greedy, #dp

## 审题（关键词） 
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列


## 初始思路  
看到最长，第一反应是穷举  
使用回溯算法找到所有子集，看最长。 

可以使用贪心算法：
- 局部：删除每一段单调上的最优，
- 全局：保留峰值和谷值，这些值是最长的子序列

如何在代码上取峰值？
1. 一般情况：i-1, i, i+1. 
   - prediff(n[i]-n[i-1]) < 0 且postDiff(n[i+1]-n[i])
   - 或 prediff(n[i]-n[i-1]) > 0 postDiff(n[i+1]-n[i]) < 0 即可
2. 但是考虑有平坡的情况：所以可以
   - (preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)
3. 考虑数组两端：
   - 设置prediff 为0 和postdiff为0
4. 单调的平坡不能算峰值
   - 在坡度发生变化时才更新prediff
## 考点  

## 解法  
```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }

        int preDiff = 0;
        int currDiff = 0;
        int ans = 1;

        for (int i = 1; i < nums.length; i++) {
            // 计算当前的坡度
            currDiff = nums[i] - nums[i - 1];
            // 比较当前的坡度和之前的坡度，有没有发生波动 ( v 和 A)
            // 等于0处理平坡
            if ((preDiff >= 0 && currDiff < 0) || (preDiff <= 0 && currDiff > 0)) {
                // 如果发生波动了：
                // 峰值加1
                ans++;

                // 只需要在 这个坡度 摆动变化的时候，更新prediff，
                // 这样prediff在 单调区间有平坡的时候 就不会发生变化
                // 交换坡度：
                preDiff = currDiff;
            }
        }

        return ans;
    }
}
```


## 难点
贪心算法中：坡度的三种情况

## 扩展：
考虑用动态规划的思想来解决这个问题。

很容易可以发现，对于我们当前考虑的这个数，
- 要么是作为山峰（即nums[i] > nums[i-1]），
- 要么是作为山谷（即nums[i] < nums[i - 1]）。

- 设dp状态dp[i][0]，表示考虑前i个数，第i个数作为山峰的摆动子序列的最长长度
- 设dp状态dp[i][1]，表示考虑前i个数，第i个数作为山谷的摆动子序列的最长长度
> 则转移方程为：
> - dp[i][0] = max(dp[i][0], dp[j][1] + 1)，其中0 < j < i且nums[j] < nums[i]，
>   - 表示将nums[i]接到前面某个山谷后面，作为山峰。
> - dp[i][1] = max(dp[i][1], dp[j][0] + 1)，其中0 < j < i且nums[j] > nums[i]，
>   - 表示将nums[i]接到前面某个山峰后面，作为山谷。

```java
// DP
class Solution {
    public int wiggleMaxLength(int[] nums) {
        // 0 i 作为波峰的最大长度
        // 1 i 作为波谷的最大长度
        int dp[][] = new int[nums.length][2];

        dp[0][0] = dp[0][1] = 1;
        for (int i = 1; i < nums.length; i++){
            //i 自己可以成为波峰或者波谷
            dp[i][0] = dp[i][1] = 1;

            for (int j = 0; j < i; j++){
                if (nums[j] > nums[i]){
                    // i 是波谷
                    dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1);
                }
                if (nums[j] < nums[i]){
                    // i 是波峰
                    dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1);
                }
            }
        }

        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
    }
}

```